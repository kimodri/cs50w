# Event Delegation

Event delegation is a design pattern in JavaScript used to handle events efficiently. Instead of attaching a separate event listener to every single element you want to interact with, you attach a single listener to a common parent element. This is especially useful for handling events on elements that are added to the page dynamically.

-----

### Static vs. Dynamic Elements

To understand why event delegation is so useful, it helps to distinguish between **static** and **dynamic** elements:

  * **Static Elements** are those that are present in the HTML when the page first loads. For these elements, using `document.querySelector()` to attach an event listener works just fine. For example, if you have a single search bar on your page, you can reliably use `querySelector` to get it and add a listener.

  * **Dynamic Elements** are created and added to the page later using JavaScript. In your code, the new posts and their "Hide" buttons are dynamic because they are generated by the `addPost()` function, which is called after the page has loaded. This is why your original code failed—the `querySelector` was run before these new buttons existed.

-----
### Why It's Better for Your Code

Your original code, `document.querySelector("button").onclick = () => {...}`, only attaches an event listener to the **first** button it finds on the page.

However, your `addPost()` function dynamically creates new buttons with the class `hide` every time `load()` is called. These new buttons don't have an event listener. So, when a user clicks on one of these new "hide" buttons, nothing happens.

Event delegation solves this problem.

-----

### The Solution: Event Delegation in Practice

Your instructor's solution places a single event listener on the `document` itself, which acts as the ultimate parent container for all your posts.

```javascript
document.addEventListener('click', event => {
    // Check if the clicked element has the class 'hide'
    const element = event.target;
    if (element.className === 'hide') {
        // If it does, remove its parent element (the post div)
        element.parentElement.remove();
    }
});
```

Here's how this works:

1.  **A single listener is attached:** The code adds just one event listener to the entire `document`. This listener is ready to "catch" any click events that happen on the page.

2.  **The event bubbles up:** When a user clicks on a "hide" button, the click event doesn't just stay on the button. It **bubbles up** the DOM tree, from the button to its parent, to the parent's parent, and all the way up to the `document` where the listener is waiting.

3.  **The listener checks the target:** The event handler function is triggered. Inside it, `event.target` refers to the original element that was clicked—in this case, the `button` with the class `hide`. The `if` statement checks this, and if it's the correct element, the post is removed.

This approach is more efficient and scalable because it automatically works for all future "hide" buttons you create, without the need to attach a new listener each time.